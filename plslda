    def plslda(self, num, percentage):
        """
        Performs supervised pls-lda as long as there are more than 2 classes (or labels).
        
        Parameters
        ----------
        num : int
            number of expected components.
        percentage: float
            0 - 1 (how much percentage for training data)
            1 doesnt split the data and no statistics
        Returns
        -------
        scores: hyperobject
            scores of pls_lda 
        loadings: hyperobject
            loadings of pls_lda
        """
        nor = 1
        unique = self.label.unique()
        copy = np.zeros(len(self.label))  
        for count in range(len(self.label)):
            for count1 in range(len(unique)):
                if self.label.iloc[count] == unique[count1]:
                    copy[count] = count1
        #return copy
        if percentage == 1:
            X_train = self.data.copy()
            y_train = copy
            pls = PLSRegression(n_components = num, scale = nor)        
            pls.fit(X_train, y_train)
            x_r_train, y_r_train = pls.transform(X_train, y_train)

        else:
            X_train, X_test, y_train, y_test = train_test_split(self.get_data().values, copy, train_size = percentage, random_state=42)
            #PLS components of testing
            pls = PLSRegression(n_components = num, scale = nor)        
            pls.fit(X_train, y_train)
            x_r_train, y_r_train = pls.transform(X_train, y_train)
            x_r_test, y_r_test = pls.transform(X_test, y_test)

        clf = LinearDiscriminantAnalysis(solver = 'svd', n_components = num-1)   
        clf.fit(x_r_train, y_train)      
        x_l_train = clf.transform(x_r_train)     
        print('\n Variance per component: \n', clf.explained_variance_ratio_, "\n")

        if percentage < 1: 
            y_pred = clf.predict(x_r_test)
            copy = []
            for count in range(len(y_train)):
                for count1 in range(len(unique)):
                    if y_train[count] == count1:
                        copy.append(unique[count1])
            
            names = unique.astype(str).tolist()
            
            print(classification_report(np.array(y_test), np.array(y_pred), target_names = names))
            
            scores = hyper_object('scores')
            scores.set_data(np.transpose(x_l_train))
            scores.set_label(copy)
            scores.set_position(pd.DataFrame(np.zeros((len(scores.data), 2))))
            
            loadings = hyper_object('loadings')
            loadings.set_data(np.transpose(pls.x_loadings_))
            loadings.set_wavenumber(pd.to_numeric(self.data.columns))
            loadings.set_label(np.arange(1, num+1))           
            return (scores, loadings)
        else:
            scores = hyper_object('scores')
            scores.set_data(np.transpose(x_l_train))
            scores.set_label(self.label)
            scores.set_position(pd.DataFrame(np.zeros((len(scores.data), 2))))
            
            loadings = hyper_object('loadings')
            loadings.set_data(np.transpose(pls.x_loadings_))
            loadings.set_wavenumber(pd.to_numeric(self.data.columns))
            loadings.set_label(np.arange(1, num+1))
            return (scores, loadings) 
